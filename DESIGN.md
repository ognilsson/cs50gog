# Our Design

### Overview of Happy Track Design
Happy Track is a model-view-controller design written in Python using a SQL database. The HTML code uses a Jinga template to show dynamic data from the model. We used Flask as our web server framework. For the user interface, we used JQuery, CSS, and some Bootstrap to display some of the widgets like the date picker (in the calendar on the history page), the sliders (for the sleep section of the survey), and the toggle bar (for the privacy setting under preferences).

Since we ask the user to submit forms for various purposes in the app (partially through HTML forms), our controllers check for a POST. If POST is submitted, the controller processes the submitted data. If data is not submitted, it just renders the HTML form. One challenge we encountered was being able to render the Jinja templates exactly how we wanted them. There were some tricks that we had to use in order to get things to display in Jinja. These can be seen in index.html and in history.html. In addition, it was tricky to get the datepicker to display, but we decided to do so in order to let the user click the date for the entries they’d like to see, rather than simply displaying a table of all entries at once.

### Table structure:

The central design element of this project is the table arrangement which has several tables coordinated and linked in order to make entry input both fluid and dynamic. The users table stores all of the users registered on our website  along with a firstTime variable that allows us to prompt users for their preferences the first time they register and log in for an account. Our users_scores table is perhaps the most important because it keeps track of the individual entries that each user inputs giving each entry and entry_id such that every single entry is distinguishable even if they happen on the same day. The user_scores table also stores the user’s mood scores and written responses to prompted questions which are central data values from the journaling process. An important thing to note in our design is the absence of activities from the user_scores table. This is because we wanted a separate table for storing all of the activity choices that a user will have which allows for each activity to be linked via foreign key to a category (from the categories table) which a user will select as preferences. The activities table, as a separate entity, allows our program to be more dynamic since users can now select from an easily adjustable list of activities (it would be easy to add a new activity and its icon), we can loop through all the activities for display purposes (such as when we display all the activity icons on activities.html), and the user can still input activities into a separate activitiy_entry table which is linked to that users other components for that entry (such as mood score and written responses) via entry_id. The preferences table also stores each user’s preferences (which are used for activity selection and tips) and is linked to the users table via foreign key. We only display the activities for the preferences selected by querying for those activities’ category_id. This design allows us to have the preferences feature and allows for more flexibility in choosing activities. The question table stores several questions which will be selected randomly to be asked to the users during the entry pathway.

The habit tracker feature uses a habits table which stores the activity that the user is tracking as well as their progress for that activity. The habits function only allows users to track one habit at a time and the options for habits to track are the activities from the activities table. Progress is displayed using CSS and simple geometry to obtain a circular percentage for showing habit progression.

### Sleep slider and History JavaScript
For the sleep slider and the date picker in the history html, most of the javascript was available online (source code). We had to iterate on the source code for our customized needs. For example, for the date picker, the source code had a text box that you click on to show the calendar, and we wanted to get it to show the calendar itself. For the sleep slider, it was challenging to get it to work with our own icon (we used a sleep emoji as the icon that you slide). We had to play around with the CSS a bit to get that piece to work. We think that the slider is an easier and more enjoyable way for the user to enter their sleep duration since they do not have to type in an integer. Most of the form is designed this way - the user can click (or on a mobile phone, tap) to complete the survey without having to spend too much time typing. These creative user interfaces also contribute to a fun journaling experience and ultimately happier users, which was the goal all along.

### Happiness and Sleep Statistics pages
The entire user interface is designed to be responsive to the user’s actions. For example, on all of the statistics pages, different parts of the graphs highlight themselves when the user scrolls over them and labels are displayed. Although more effort to implement, we made this design choice because we researched user interface designs and found that users enjoy user interfaces that feel responsive to their actions. Having the user interface change dynamically based on where the cursor is located accomplishes this. To create the graphs and the bar charts, we decided to use Charts.js after extensive research on best practices and aesthetics of different methods. Although Charts.js is slightly more complicated than other visualization tools such as matplotlib for example, we decided that the benefits it entailed was worth spending some extra time implementing it. The most challenging part of creating these charts was setting up the configuration of the graph since Charts.js is very particular with how variables and configuration must be set up, but once the structure was in place, the results proved to be worth the trouble. In addition, because the graphs are linked to specific html pages and require different sets of data, we decided to include the JavaScript code in the individual html files themselves as opposed to a separate file, just for the sake of clarity.

### Behind the scenes – statistics
Python is a powerful tool when it comes to arithmetic and manipulating lists, dictionaries, and the like so the raw data which goes into the graphs is produced in python, whereupon it’s passed to the relevant html as lists and rendered with Jinja. Some basic steps such as the “back_one_day()” function were also moved to helpers.py for simplicity. For the line charts (Overall Happiness and Sleep), we start by obtaining the scope (how far back we want to look for data) which is determined by a form in the html which automatically updates as the user changes the range. If the user just clicks the link in the navigation bar, no form is submitted so the first try statement essentially just ensures that the default is 7 days (1 week) if that happens. After that, we account for the case when the scope is a month, which means one month back in time means either 31, 30, or 28 days back. Next, we’re querying the database for the average happiness (in case of multiple inputs during a day) for the given scope with a for loop, starting with today and moving back one day at the time, continuously storing the outputs in an “x” and a “y” list. If no data was inputted, that is signaled with a 0.5 value which will be labeled “No input” in the graphs. Lastly, we reverse both lists to get the dates in chronological order and adjust the title depending on the scope.

### Activities stats
Another feature we thought was crucial for this web- app was the ability to give users valuable feedback on what they can do to improve their overall happiness. This was achieved by calculating what activities are associated with the highest average happiness. As seen in both the /social and the /activitiy_stats route, this is done by collecting all scores for every given activity, averaging the overall happiness over all of those entries, and lastly filtering out which 3 activities those with the highest averages, and which 3 those with the lowest averages. This is displayed to the user in the form of two separate tables. The difference between social and the personal activity statistics is that the social page displays this information but across all users who have indicated that they don’t mind sharing their data under their preferences.

### Sleep stats
Similarly, the sleep statistics page is also aimed to let the user see trends in their sleeping pattern. It’s also responsive so that if the user sleeps less than 7 hours, it will encourage the user to sleep more. If the user sleeps between 7 and 9.5 hours, it’s deemed to be healthy and we celebrate that, and if the user sleeps more than 9.5 we encourage the user to think about using some of that time for other purposes. These messages are displayed along with the average number of hours of sleep for the user under the graph itself.

### Email feature
One problem we encountered and spent a lot of time trying to solve was how to set up the email feature. This was crucial for the forgot-password function and was the entire reason we decided that users should register with an email address instead of a username. Because we were working in the cs50 ide and had to submit a fully functioning version, it seemed easiest to create a new gmail of which we felt comfortable sharing the information with a grader. To relieve the grader from having to set up environment variables etc. we decided to leave the gmail information open. In a case where this website would actually be implemented, this would naturally be changed for security reasons.

We decided to make the background black because we think it gave the app a more elegant feel.
